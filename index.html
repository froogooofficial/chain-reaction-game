<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Chain Reaction ‚Äî Can You Beat the AI?</title>
<meta name="description" content="A viral strategy game. Place orbs, trigger chain reactions, outsmart the AI. Think you can win?">
<meta property="og:title" content="Chain Reaction ‚Äî Can You Beat the AI? üß†‚ö°">
<meta property="og:description" content="I just played Chain Reaction against an AI. Think you can beat my score? Try it now!">
<meta property="og:image" content="https://froogooofficial.github.io/chain-reaction-game/og-image.jpg">
<meta property="og:image:width" content="1024">
<meta property="og:image:height" content="1024">
<meta property="og:url" content="https://froogooofficial.github.io/chain-reaction-game/">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Chain Reaction ‚Äî Can You Beat the AI? üß†‚ö°">
<meta name="twitter:description" content="A viral strategy game. Place orbs, trigger chain reactions, outsmart the AI.">
<meta name="twitter:image" content="https://froogooofficial.github.io/chain-reaction-game/og-image.jpg">
<title>Chain Reaction ‚ö°</title>
<meta property="og:title" content="Chain Reaction ‚ö°">
<meta property="og:description" content="Outsmart the AI in this explosive strategy game! Place orbs, trigger chain reactions, dominate the board.">
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Inter',sans-serif;background:#0a0a0a;color:#fff;min-height:100vh;display:flex;align-items:center;justify-content:center;overflow:hidden;touch-action:manipulation;-webkit-user-select:none;user-select:none}
.container{width:100%;max-width:420px;padding:1rem;text-align:center}

/* START */
#start-screen .logo{font-size:4rem;margin-bottom:0.5rem}
#start-screen h1{font-size:2.4rem;font-weight:900;background:linear-gradient(135deg,#0077B5,#004C75);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:0.3rem}
#start-screen .sub{color:#888;font-size:0.85rem;margin-bottom:1.5rem;line-height:1.6}
.rules-box{background:#151515;border:1px solid #222;border-radius:16px;padding:1.2rem;margin-bottom:1.5rem;text-align:left;font-size:0.8rem;color:#aaa;line-height:1.7}
.rules-box b{color:#fff}
.btn-play{background:linear-gradient(135deg,#0077B5,#005885);color:#fff;border:none;padding:1rem 3rem;font-size:1.15rem;font-weight:700;border-radius:50px;cursor:pointer;font-family:inherit;transition:transform .2s}
.btn-play:active{transform:scale(.96)}
.diff-select{display:flex;gap:0.6rem;justify-content:center;margin-bottom:1.2rem}
.diff-btn{background:#151515;border:2px solid #333;color:#888;padding:0.6rem 1.4rem;font-size:0.85rem;font-weight:700;border-radius:50px;cursor:pointer;font-family:inherit;transition:all .2s}
.diff-btn.active{border-color:#0077B5;color:#0077B5;box-shadow:0 0 12px rgba(0,119,181,0.2)}
.diff-btn:hover{border-color:#555;color:#aaa}

/* GAME */
#game-screen{display:none}
.hud{display:flex;justify-content:space-between;align-items:center;margin-bottom:0.8rem;padding:0 0.2rem}
.hud-player{display:flex;align-items:center;gap:0.4rem;font-weight:700;font-size:0.85rem;padding:0.4rem 0.8rem;border-radius:10px;border:2px solid transparent;transition:all .3s}
.hud-player.active{border-color:currentColor}
.hud-player.p1{color:#0077B5}.hud-player.p2{color:#E7A33E}
.hud-center{font-size:0.75rem;color:#555}
.orb-count{font-size:1.1rem}

.grid-wrap{position:relative;margin:0 auto;border-radius:12px;overflow:visible}
.grid{display:grid;gap:3px}
.cell{background:#151515;border-radius:8px;position:relative;cursor:pointer;transition:background .15s,transform .15s;display:flex;align-items:center;justify-content:center;overflow:visible}
.cell:hover{background:#1a1a1a}
.cell.disabled{cursor:default;opacity:0.7}
.cell.flash-p1{background:rgba(0,119,181,0.25)}
.cell.flash-p2{background:rgba(231,163,62,0.25)}
.cell.exploding{transform:scale(1.1);z-index:5}

.orbs{display:flex;flex-wrap:wrap;align-items:center;justify-content:center;gap:2px;position:relative}
.orb{width:12px;height:12px;border-radius:50%;transition:all .2s}
.orb.p1{background:radial-gradient(circle at 35% 35%,#4DA8DA,#0077B5,#004C75);box-shadow:0 0 6px rgba(0,119,181,0.5)}
.orb.p2{background:radial-gradient(circle at 35% 35%,#F5CC84,#E7A33E,#B8781E);box-shadow:0 0 6px rgba(231,163,62,0.5)}

@keyframes wobble{0%,100%{transform:translateY(0)}50%{transform:translateY(-2px)}}
.orb.critical{animation:wobble .4s ease-in-out infinite}

.chain-popup{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.5rem;font-weight:900;pointer-events:none;opacity:0;z-index:50;text-shadow:0 2px 8px rgba(0,0,0,0.8)}
@keyframes chainPop{0%{opacity:1;transform:translate(-50%,-50%) scale(0.5)}50%{transform:translate(-50%,-70%) scale(1.2)}100%{opacity:0;transform:translate(-50%,-100%) scale(1)}}
.chain-popup.show{animation:chainPop .8s ease-out forwards}

.flying-orb{position:absolute;width:12px;height:12px;border-radius:50%;z-index:10;pointer-events:none;transition:left .2s ease-out,top .2s ease-out}
.flying-orb.p1{background:radial-gradient(circle at 35% 35%,#4DA8DA,#0077B5);box-shadow:0 0 8px rgba(0,119,181,0.6)}
.flying-orb.p2{background:radial-gradient(circle at 35% 35%,#F5CC84,#E7A33E);box-shadow:0 0 8px rgba(231,163,62,0.6)}

.turn-banner{font-size:0.8rem;color:#555;margin-top:0.8rem;min-height:1.5rem;font-weight:600}
.turn-banner.thinking{color:#E7A33E}

@keyframes shakeGrid{0%,100%{transform:translate(0)}25%{transform:translate(-3px,2px)}50%{transform:translate(2px,-3px)}75%{transform:translate(-2px,1px)}}
.grid-wrap.shake{animation:shakeGrid .25s ease-out}

/* LOGO IMAGE */
.logo-img{width:200px;height:200px;border-radius:20px;margin-bottom:0.5rem;box-shadow:0 0 30px rgba(0,119,181,0.3)}

/* LIGHTNING CANVAS */
#lightning-canvas{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:20}

/* EXPLOSION FLASH */
.cell.lightning-flash{transition:box-shadow .1s}
.cell.lightning-flash.p1{box-shadow:0 0 12px 4px rgba(0,119,181,0.6),inset 0 0 8px rgba(77,168,218,0.3)}
.cell.lightning-flash.p2{box-shadow:0 0 12px 4px rgba(231,163,62,0.6),inset 0 0 8px rgba(245,204,132,0.3)}

/* RESULT */
#result-screen{display:none}
.result-emoji{font-size:4rem;margin-bottom:0.5rem}
.result-title{font-size:1.8rem;font-weight:900;margin-bottom:0.2rem}
.result-subtitle{color:#888;font-size:0.9rem;margin-bottom:1.5rem}
.result-stats{display:flex;justify-content:center;gap:1.5rem;margin-bottom:1.5rem}
.stat{text-align:center}
.stat-val{font-size:1.4rem;font-weight:800}
.stat-val.p1{color:#0077B5}.stat-val.p2{color:#E7A33E}
.stat-lbl{font-size:0.65rem;color:#555;text-transform:uppercase;letter-spacing:1px}
.btn-share{width:100%;padding:0.9rem;font-size:0.95rem;font-weight:700;border:none;border-radius:50px;cursor:pointer;font-family:inherit;margin-bottom:0.6rem;color:#fff;transition:transform .2s;display:flex;align-items:center;justify-content:center;gap:0.5rem}
.btn-share:active{transform:scale(.97)}
.btn-share.linkedin{background:#0077b5}
.btn-share.twitter{background:#1da1f2}
.btn-share.whatsapp{background:#25d366}
.btn-share.copy{background:#333}
.btn-replay{background:transparent;color:#888;border:1px solid #333;padding:0.7rem;font-size:0.85rem;font-weight:600;border-radius:50px;cursor:pointer;font-family:inherit;width:100%;margin-top:0.3rem}
.btn-replay:hover{color:#fff;border-color:#555}
</style>
</head>
<body>
<div class="container">

<!-- START SCREEN -->
<div id="start-screen">
  <img src="og-image.jpg" alt="Chain Reaction" class="logo-img">
  <p class="sub" style="margin-top:0.5rem">Outsmart the AI. Trigger the chain. ‚ö°</p>
  <div class="rules-box">
    <b>üîµ You</b> vs <b style="color:#E7A33E">üü° AI</b><br>
    Tap to place orbs in cells.<br>
    When a cell hits <b>critical mass</b>, it explodes into neighbors!<br>
    <b>Corners</b> = 2 ¬∑ <b>Edges</b> = 3 ¬∑ <b>Center</b> = 4<br>
    Explosions <b>capture</b> opponent orbs and can chain!<br>
    <b>Eliminate all opponent orbs to win.</b>
  </div>
  <div class="diff-select">
    <button class="diff-btn" data-d="easy" onclick="setDiff('easy')">üå± Easy</button>
    <button class="diff-btn active" data-d="hard" onclick="setDiff('hard')">üß† Hard</button>
  </div>
  <button class="btn-play" onclick="startGame()">Play ‚ö°</button>
  <p style="margin-top:1.5rem;font-size:0.7rem;color:#444">Created by Dan Shamir & Arlo ü§ñ</p>
</div>

<!-- GAME SCREEN -->
<div id="game-screen">
  <div class="hud">
    <div class="hud-player p1" id="hud-p1">üîµ <span class="orb-count" id="count-p1">0</span></div>
    <div class="hud-center" id="move-count">Move 1</div>
    <div class="hud-player p2" id="hud-p2"><span class="orb-count" id="count-p2">0</span> üü°</div>
  </div>
  <div class="grid-wrap" id="grid-wrap">
    <canvas id="lightning-canvas"></canvas>
    <div class="grid" id="grid"></div>
  </div>
  <div class="turn-banner" id="turn-banner">Your turn ‚Äî tap a cell</div>
</div>

<!-- RESULT SCREEN -->
<div id="result-screen">
  <div class="result-emoji" id="r-emoji"></div>
  <div class="result-title" id="r-title"></div>
  <div class="result-subtitle" id="r-sub"></div>
  <div class="result-stats">
    <div class="stat"><div class="stat-val" id="r-moves">0</div><div class="stat-lbl">Moves</div></div>
    <div class="stat"><div class="stat-val" id="r-chain">0</div><div class="stat-lbl">Best Chain</div></div>
    <div class="stat"><div class="stat-val" id="r-captured">0</div><div class="stat-lbl">Captured</div></div>
    <div class="stat"><div class="stat-val" id="r-streak">0</div><div class="stat-lbl">Win Streak</div></div>
  </div>
  <button class="btn-share linkedin" onclick="shareLinkedIn()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
    Share on LinkedIn
  </button>
  <button class="btn-share twitter" onclick="shareTwitter()">Share on ùïè</button>
  <button class="btn-share whatsapp" onclick="shareWhatsApp()">Share on WhatsApp</button>
  <button class="btn-share copy" onclick="copyResult()">üìã Copy Result</button>
  <button class="btn-replay" onclick="startGame()">Play Again ‚ö°</button>
  <p style="margin-top:1rem;font-size:0.7rem;color:#444">Created by Dan Shamir & Arlo ü§ñ</p>
</div>

</div>

<script>
// ===== CONSTANTS =====
const ROWS = 9, COLS = 6;
let CELL_SIZE = 50, GAP = 3;
const ANIM_DELAY = 220;

// ===== STATE =====
let board, currentPlayer, totalMoves, animating, gameOver;
let stats = { moves: 0, bestChain: 0, captured: 0, winStreak: 0 };

// ===== AUDIO =====
let audioCtx;
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function playTone(freq, dur, type='sine', vol=0.08) {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol; g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  } catch(e) {}
}
function sndPlace() { playTone(350, 0.08); }
function sndExplode(n) { playTone(300 + n * 60, 0.12, 'square', 0.06); }
function sndWin() { [523,659,784].forEach((f,i) => setTimeout(() => playTone(f, 0.25), i*100)); }
function sndLose() { [400,350,300].forEach((f,i) => setTimeout(() => playTone(f, 0.25), i*120)); }

// ===== BOARD LOGIC =====
function critMass(r, c) {
  let n = 4;
  if (r === 0 || r === ROWS-1) n--;
  if (c === 0 || c === COLS-1) n--;
  return n;
}
function neighbors(r, c) {
  const ns = [];
  if (r > 0) ns.push([r-1,c]);
  if (r < ROWS-1) ns.push([r+1,c]);
  if (c > 0) ns.push([r,c-1]);
  if (c < COLS-1) ns.push([r,c+1]);
  return ns;
}
function countOrbs(b, player) {
  let n = 0;
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (b[r][c].owner === player) n += b[r][c].count;
  return n;
}
function deepCopy(b) {
  return b.map(row => row.map(cell => ({...cell})));
}
function isGameOver(b) {
  if (totalMoves < 2) return 0;
  const p1 = countOrbs(b, 1), p2 = countOrbs(b, 2);
  if (p1 === 0) return 2;
  if (p2 === 0) return 1;
  return 0;
}

// Pure simulation (no animation)
function simulate(b, r, c, player) {
  b[r][c].count++;
  b[r][c].owner = player;
  let chainLen = 0, captured = 0, iters = 0;
  while (iters++ < 200) {
    const toExplode = [];
    for (let rr = 0; rr < ROWS; rr++)
      for (let cc = 0; cc < COLS; cc++)
        if (b[rr][cc].count >= critMass(rr, cc)) toExplode.push([rr,cc]);
    if (!toExplode.length) break;
    chainLen++;
    for (const [er, ec] of toExplode) {
      b[er][ec].count -= critMass(er, ec);
      if (b[er][ec].count <= 0) { b[er][ec].count = 0; b[er][ec].owner = 0; }
      for (const [nr, nc] of neighbors(er, ec)) {
        if (b[nr][nc].owner !== 0 && b[nr][nc].owner !== player) captured++;
        b[nr][nc].count++;
        b[nr][nc].owner = player;
      }
    }
    // Check early termination
    let p1 = false, p2 = false;
    for (let rr = 0; rr < ROWS; rr++)
      for (let cc = 0; cc < COLS; cc++) {
        if (b[rr][cc].owner === 1) p1 = true;
        if (b[rr][cc].owner === 2) p2 = true;
      }
    if (totalMoves >= 1 && (!p1 || !p2)) break;
  }
  return { board: b, chainLen, captured };
}

// ===== AI =====
let aiDifficulty = 'hard';

function setDiff(d) {
  aiDifficulty = d;
  document.querySelectorAll('.diff-btn').forEach(b => b.classList.toggle('active', b.dataset.d === d));
}

function getValidMoves(b, player) {
  const moves = [];
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (b[r][c].owner === 0 || b[r][c].owner === player) moves.push([r, c]);
  return moves;
}

function evaluate(b, aiPlayer, humanPlayer, moveNum) {
  const aiOrbs = countOrbs(b, aiPlayer);
  const huOrbs = countOrbs(b, humanPlayer);
  if (moveNum >= 2 && huOrbs === 0) return 100000;
  if (moveNum >= 2 && aiOrbs === 0) return -100000;

  let aiCells = 0, huCells = 0;
  let aiPressure = 0, huPressure = 0;
  let aiCorners = 0, huCorners = 0;
  let aiEdges = 0, huEdges = 0;
  let aiVulnerable = 0, huVulnerable = 0;
  let aiThreats = 0, huThreats = 0;

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = b[r][c];
      if (cell.owner === 0) continue;
      const cm = critMass(r, c);
      const isAi = cell.owner === aiPlayer;

      if (isAi) {
        aiCells++;
        // Critical cells about to explode = pressure/threat
        if (cell.count === cm - 1) {
          aiPressure++;
          // Count how many enemy neighbors this threatens
          for (const [nr, nc] of neighbors(r, c)) {
            if (b[nr][nc].owner === humanPlayer) aiThreats++;
          }
        }
        // Position value
        if (cm === 2) aiCorners++;
        else if (cm === 3) aiEdges++;
        // Vulnerability: adjacent to enemy critical cell
        for (const [nr, nc] of neighbors(r, c)) {
          if (b[nr][nc].owner === humanPlayer && b[nr][nc].count === critMass(nr, nc) - 1) {
            aiVulnerable++;
            break;
          }
        }
      } else {
        huCells++;
        if (cell.count === cm - 1) {
          huPressure++;
          for (const [nr, nc] of neighbors(r, c)) {
            if (b[nr][nc].owner === aiPlayer) huThreats++;
          }
        }
        if (cm === 2) huCorners++;
        else if (cm === 3) huEdges++;
        for (const [nr, nc] of neighbors(r, c)) {
          if (b[nr][nc].owner === aiPlayer && b[nr][nc].count === critMass(nr, nc) - 1) {
            huVulnerable++;
            break;
          }
        }
      }
    }
  }

  let score = 0;
  score += (aiOrbs - huOrbs) * 3;           // Raw material
  score += (aiCells - huCells) * 5;           // Territory
  score += (aiCorners - huCorners) * 8;       // Corners are king
  score += (aiEdges - huEdges) * 3;           // Edges are good
  score += (aiPressure - huPressure) * 4;     // Critical mass pressure
  score += (aiThreats - huThreats) * 6;       // Threatening enemy cells
  score -= (aiVulnerable) * 7;                // Penalize being vulnerable
  score += (huVulnerable) * 5;                // Reward opponent vulnerability
  return score;
}

function minimax(b, depth, alpha, beta, isMaximizing, aiPlayer, humanPlayer, moveNum) {
  const aiOrbs = countOrbs(b, aiPlayer);
  const huOrbs = countOrbs(b, humanPlayer);
  if (moveNum >= 2 && huOrbs === 0) return 100000 + depth;
  if (moveNum >= 2 && aiOrbs === 0) return -100000 - depth;
  if (depth === 0) return evaluate(b, aiPlayer, humanPlayer, moveNum);

  const player = isMaximizing ? aiPlayer : humanPlayer;
  const moves = getValidMoves(b, player);
  if (moves.length === 0) return evaluate(b, aiPlayer, humanPlayer, moveNum);

  // Move ordering: prioritize cells near critical mass and corners for better pruning
  moves.sort((a, b_) => {
    const [ar, ac] = a, [br, bc] = b_;
    let sa = 0, sb = 0;
    const cellA = b[ar][ac], cellB = b[br][bc];
    // Own cells near critical mass first
    if (cellA.owner === player && cellA.count === critMass(ar, ac) - 1) sa += 20;
    if (cellB.owner === player && cellB.count === critMass(br, bc) - 1) sb += 20;
    // Corners
    sa += (4 - critMass(ar, ac)) * 3;
    sb += (4 - critMass(br, bc)) * 3;
    return sb - sa;
  });

  if (isMaximizing) {
    let best = -Infinity;
    for (const [r, c] of moves) {
      const sim = deepCopy(b);
      simulate(sim, r, c, player);
      const val = minimax(sim, depth - 1, alpha, beta, false, aiPlayer, humanPlayer, moveNum + 1);
      best = Math.max(best, val);
      alpha = Math.max(alpha, val);
      if (beta <= alpha) break;
    }
    return best;
  } else {
    let best = Infinity;
    for (const [r, c] of moves) {
      const sim = deepCopy(b);
      simulate(sim, r, c, player);
      const val = minimax(sim, depth - 1, alpha, beta, true, aiPlayer, humanPlayer, moveNum + 1);
      best = Math.min(best, val);
      beta = Math.min(beta, val);
      if (beta <= alpha) break;
    }
    return best;
  }
}

function aiMove() {
  const valid = getValidMoves(board, 2);
  if (valid.length === 0) return valid[0];

  // === EASY MODE: mostly random ===
  if (aiDifficulty === 'easy') {
    // 75% random, 25% uses basic greedy
    if (Math.random() < 0.75) {
      return valid[Math.floor(Math.random() * valid.length)];
    }
    // Basic greedy for the 25%
    let bestScore = -Infinity, bestMoves = [];
    for (const [r, c] of valid) {
      const sim = deepCopy(board);
      const result = simulate(sim, r, c, 2);
      if (totalMoves >= 1 && countOrbs(result.board, 1) === 0) return [r, c];
      let score = countOrbs(result.board, 2) - countOrbs(result.board, 1) + result.captured * 3;
      if (score > bestScore) { bestScore = score; bestMoves = [[r, c]]; }
      else if (score === bestScore) bestMoves.push([r, c]);
    }
    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
  }

  // === HARD MODE: deep minimax ===
  // Determine search depth based on game phase
  let filledCells = 0;
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (board[r][c].owner !== 0) filledCells++;

  // Deeper search when fewer empty cells (faster to compute)
  let depth = filledCells > 30 ? 3 : 2;
  // But also check: if few valid moves, go deeper
  if (valid.length < 20) depth = Math.max(depth, 3);
  if (valid.length < 12) depth = 4;

  let bestScore = -Infinity, bestMoves = [];
  for (const [r, c] of valid) {
    const sim = deepCopy(board);
    const result = simulate(sim, r, c, 2);

    // Instant win
    if (totalMoves >= 1 && countOrbs(result.board, 1) === 0) return [r, c];

    let score = minimax(result.board, depth - 1, -Infinity, Infinity, false, 2, 1, totalMoves + 2);

    // Tiebreak: prefer corners, then edges
    const cm = critMass(r, c);
    score += (cm === 2 ? 0.3 : cm === 3 ? 0.1 : 0);

    if (score > bestScore) { bestScore = score; bestMoves = [[r, c]]; }
    else if (score === bestScore) bestMoves.push([r, c]);
  }

  return bestMoves[Math.floor(Math.random() * bestMoves.length)];
}

// ===== RENDERING =====
const $ = id => document.getElementById(id);
const gridEl = $('grid');
const gridWrap = $('grid-wrap');

function initGrid() {
  // Calculate cell size based on screen
  const maxW = Math.min(420, window.innerWidth - 32);
  CELL_SIZE = Math.floor((maxW - GAP * (COLS - 1)) / COLS);
  const gridW = CELL_SIZE * COLS + GAP * (COLS - 1);
  const gridH = CELL_SIZE * ROWS + GAP * (ROWS - 1);

  gridEl.style.gridTemplateColumns = `repeat(${COLS}, ${CELL_SIZE}px)`;
  gridEl.style.gridTemplateRows = `repeat(${ROWS}, ${CELL_SIZE}px)`;
  gridEl.style.gap = GAP + 'px';
  gridWrap.style.width = gridW + 'px';
  gridWrap.style.height = gridH + 'px';

  gridEl.innerHTML = '';
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.addEventListener('click', () => onCellClick(r, c));
      const orbsDiv = document.createElement('div');
      orbsDiv.className = 'orbs';
      cell.appendChild(orbsDiv);
      gridEl.appendChild(cell);
    }
  }
}

function cellEl(r, c) { return gridEl.children[r * COLS + c]; }

function cellCenter(r, c) {
  return {
    x: c * (CELL_SIZE + GAP) + CELL_SIZE / 2,
    y: r * (CELL_SIZE + GAP) + CELL_SIZE / 2
  };
}

function renderBoard() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = cellEl(r, c);
      const orbsDiv = cell.querySelector('.orbs');
      const { count, owner } = board[r][c];
      const isCrit = count === critMass(r, c) - 1 && owner !== 0;

      orbsDiv.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const orb = document.createElement('div');
        orb.className = `orb p${owner}${isCrit ? ' critical' : ''}`;
        orbsDiv.appendChild(orb);
      }
    }
  }
  // Update HUD
  $('count-p1').textContent = countOrbs(board, 1);
  $('count-p2').textContent = countOrbs(board, 2);
  $('hud-p1').classList.toggle('active', currentPlayer === 1 && !gameOver);
  $('hud-p2').classList.toggle('active', currentPlayer === 2 && !gameOver);
}

// ===== ANIMATED EXPLOSIONS =====
function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

// ===== LIGHTNING EFFECTS =====
const lCanvas = $('lightning-canvas');
const lCtx = lCanvas ? lCanvas.getContext('2d') : null;
let lightningBolts = [];

function resizeLightningCanvas() {
  if (!lCanvas) return;
  lCanvas.width = gridWrap.offsetWidth;
  lCanvas.height = gridWrap.offsetHeight;
}

function drawLightningBolt(ctx, x1, y1, x2, y2, color, glow, thickness) {
  const segments = 8 + Math.floor(Math.random() * 5);
  const dx = (x2 - x1) / segments;
  const dy = (y2 - y1) / segments;
  const jitter = Math.sqrt((x2-x1)**2 + (y2-y1)**2) * 0.15;
  
  ctx.save();
  // Outer glow
  ctx.shadowColor = glow;
  ctx.shadowBlur = 15;
  ctx.strokeStyle = glow;
  ctx.lineWidth = thickness + 4;
  ctx.globalAlpha = 0.4;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  let px = x1, py = y1;
  for (let i = 1; i <= segments; i++) {
    const nx = i === segments ? x2 : x1 + dx * i + (Math.random() - 0.5) * jitter;
    const ny = i === segments ? y2 : y1 + dy * i + (Math.random() - 0.5) * jitter;
    ctx.lineTo(nx, ny);
    px = nx; py = ny;
  }
  ctx.stroke();
  
  // Core bolt
  ctx.shadowBlur = 8;
  ctx.shadowColor = color;
  ctx.strokeStyle = color;
  ctx.lineWidth = thickness;
  ctx.globalAlpha = 0.9;
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  px = x1; py = y1;
  for (let i = 1; i <= segments; i++) {
    const nx = i === segments ? x2 : x1 + dx * i + (Math.random() - 0.5) * jitter;
    const ny = i === segments ? y2 : y1 + dy * i + (Math.random() - 0.5) * jitter;
    ctx.lineTo(nx, ny);
  }
  ctx.stroke();
  
  // Bright center
  ctx.shadowBlur = 4;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = Math.max(1, thickness - 1);
  ctx.globalAlpha = 0.6;
  ctx.stroke();
  ctx.restore();
}

function spawnLightning(fromR, fromC, toR, toC, player) {
  const from = cellCenter(fromR, fromC);
  const to = cellCenter(toR, toC);
  const color = player === 1 ? '#4DA8DA' : '#F5CC84';
  const glow = player === 1 ? '#0077B5' : '#E7A33E';
  lightningBolts.push({
    x1: from.x, y1: from.y, x2: to.x, y2: to.y,
    color, glow, life: 1.0, decay: 0.04 + Math.random() * 0.02,
    thickness: 1.5 + Math.random()
  });
}

let lightningAnimating = false;
function animateLightning() {
  if (!lCtx) return;
  lCtx.clearRect(0, 0, lCanvas.width, lCanvas.height);
  lightningBolts = lightningBolts.filter(b => b.life > 0);
  for (const b of lightningBolts) {
    lCtx.globalAlpha = b.life;
    drawLightningBolt(lCtx, b.x1, b.y1, b.x2, b.y2, b.color, b.glow, b.thickness);
    b.life -= b.decay;
  }
  lCtx.globalAlpha = 1;
  if (lightningBolts.length > 0) {
    requestAnimationFrame(animateLightning);
  } else {
    lightningAnimating = false;
    lCtx.clearRect(0, 0, lCanvas.width, lCanvas.height);
  }
}

function triggerLightning(explodingCells, player) {
  resizeLightningCanvas();
  for (const [er, ec] of explodingCells) {
    for (const [nr, nc] of neighbors(er, ec)) {
      spawnLightning(er, ec, nr, nc, player);
      // Small branches
      if (Math.random() > 0.5) {
        const mid = cellCenter(er, ec);
        const to = cellCenter(nr, nc);
        const bx = (mid.x + to.x) / 2 + (Math.random() - 0.5) * 20;
        const by = (mid.y + to.y) / 2 + (Math.random() - 0.5) * 20;
        const color = player === 1 ? '#4DA8DA' : '#F5CC84';
        const glow = player === 1 ? '#0077B5' : '#E7A33E';
        lightningBolts.push({
          x1: bx, y1: by,
          x2: bx + (Math.random()-0.5)*15, y2: by + (Math.random()-0.5)*15,
          color, glow, life: 0.7, decay: 0.06, thickness: 1
        });
      }
    }
  }
  if (!lightningAnimating) {
    lightningAnimating = true;
    animateLightning();
  }
}

async function animatedPlace(r, c, player) {
  board[r][c].count++;
  board[r][c].owner = player;
  renderBoard();
  sndPlace();

  let chainLen = 0, totalCaptured = 0, iters = 0;

  while (iters++ < 200) {
    const toExplode = [];
    for (let rr = 0; rr < ROWS; rr++)
      for (let cc = 0; cc < COLS; cc++)
        if (board[rr][cc].count >= critMass(rr, cc)) toExplode.push([rr, cc]);
    if (!toExplode.length) break;
    chainLen++;
    sndExplode(chainLen);

    // Lightning effect!
    triggerLightning(toExplode, player);

    // Create flying orbs
    const flyingOrbs = [];
    for (const [er, ec] of toExplode) {
      const from = cellCenter(er, ec);
      cellEl(er, ec).classList.add('exploding');

      board[er][ec].count -= critMass(er, ec);
      if (board[er][ec].count <= 0) { board[er][ec].count = 0; board[er][ec].owner = 0; }

      for (const [nr, nc] of neighbors(er, ec)) {
        if (board[nr][nc].owner !== 0 && board[nr][nc].owner !== player) totalCaptured++;
        const to = cellCenter(nr, nc);
        const orb = document.createElement('div');
        orb.className = `flying-orb p${player}`;
        orb.style.left = (from.x - 6) + 'px';
        orb.style.top = (from.y - 6) + 'px';
        gridWrap.appendChild(orb);
        flyingOrbs.push(orb);
        // Trigger transition
        requestAnimationFrame(() => requestAnimationFrame(() => {
          orb.style.left = (to.x - 6) + 'px';
          orb.style.top = (to.y - 6) + 'px';
        }));
      }
    }

    renderBoard();
    await delay(ANIM_DELAY);

    // Apply to neighbors
    for (const [er, ec] of toExplode) {
      cellEl(er, ec).classList.remove('exploding');
      for (const [nr, nc] of neighbors(er, ec)) {
        board[nr][nc].count++;
        board[nr][nc].owner = player;
        cellEl(nr, nc).classList.add(`flash-p${player}`);
        const nEl = cellEl(nr, nc);
        nEl.classList.add('lightning-flash', `p${player}`);
      }
    }
    renderBoard();
    flyingOrbs.forEach(o => o.remove());

    // Chain popup
    if (chainLen >= 2) showChainPopup(chainLen, toExplode[0]);
    if (chainLen >= 3) gridWrap.classList.add('shake');

    await delay(80);
    // Clear flash
    for (const [er, ec] of toExplode)
      for (const [nr, nc] of neighbors(er, ec)) {
        cellEl(nr, nc).classList.remove(`flash-p1`, `flash-p2`);
        cellEl(nr, nc).classList.remove('lightning-flash', 'p1', 'p2');
      }
    gridWrap.classList.remove('shake');

    // Check game over mid-chain
    const winner = isGameOver(board);
    if (winner) { endGame(winner); return { chainLen, captured: totalCaptured }; }
  }

  if (chainLen > stats.bestChain) stats.bestChain = chainLen;
  stats.captured += totalCaptured;
  return { chainLen, captured: totalCaptured };
}

function showChainPopup(n, srcCell) {
  const popup = document.createElement('div');
  popup.className = 'chain-popup';
  const colors = ['', '#0077B5', '#E7A33E'];
  popup.style.color = n >= 5 ? '#fbbf24' : colors[currentPlayer] || '#fff';
  popup.textContent = n >= 5 ? `üí• ${n}x CHAIN!` : `‚ö° ${n}x`;
  popup.style.left = '50%'; popup.style.top = '50%';
  gridWrap.appendChild(popup);
  requestAnimationFrame(() => popup.classList.add('show'));
  setTimeout(() => popup.remove(), 900);
}

// ===== GAME FLOW =====
function startGame() {
  initAudio();
  board = [];
  for (let r = 0; r < ROWS; r++) {
    board[r] = [];
    for (let c = 0; c < COLS; c++) board[r][c] = { count: 0, owner: 0 };
  }
  currentPlayer = 1;
  totalMoves = 0;
  animating = false;
  gameOver = false;
  stats.moves = 0;
  stats.bestChain = 0;
  stats.captured = 0;

  $('start-screen').style.display = 'none';
  $('result-screen').style.display = 'none';
  $('game-screen').style.display = 'block';

  initGrid();
  renderBoard();
  updateTurnBanner();
}

function updateTurnBanner() {
  const banner = $('turn-banner');
  if (currentPlayer === 1) {
    banner.textContent = 'Your turn ‚Äî tap a cell';
    banner.className = 'turn-banner';
  } else {
    banner.textContent = aiDifficulty === 'hard' ? 'AI is thinking hard... üß†' : 'AI is thinking...';
    banner.className = 'turn-banner thinking';
  }
}

async function onCellClick(r, c) {
  if (animating || gameOver || currentPlayer !== 1) return;
  if (board[r][c].owner !== 0 && board[r][c].owner !== 1) return;

  animating = true;
  totalMoves++;
  stats.moves++;
  $('move-count').textContent = `Move ${stats.moves}`;

  await animatedPlace(r, c, 1);

  if (gameOver) return;

  // AI turn
  currentPlayer = 2;
  updateTurnBanner();
  await delay(aiDifficulty === 'hard' ? 300 : 300 + Math.random() * 200);

  if (gameOver) return;

  const [ar, ac] = aiMove();
  totalMoves++;
  await animatedPlace(ar, ac, 2);

  if (gameOver) return;

  currentPlayer = 1;
  animating = false;
  updateTurnBanner();
}

function endGame(winner) {
  gameOver = true;
  animating = false;

  if (winner === 1) {
    stats.winStreak++;
    sndWin();
  } else {
    stats.winStreak = 0;
    sndLose();
  }

  setTimeout(() => {
    $('game-screen').style.display = 'none';
    $('result-screen').style.display = 'block';

    if (winner === 1) {
      $('r-emoji').textContent = 'üèÜ';
      $('r-title').textContent = 'You Won!';
      $('r-sub').textContent = 'The AI has been eliminated.';
    } else {
      $('r-emoji').textContent = 'üíÄ';
      $('r-title').textContent = 'AI Wins';
      $('r-sub').textContent = 'The machine outsmarted you this time.';
    }

    $('r-moves').textContent = stats.moves;
    $('r-moves').className = `stat-val p${winner}`;
    $('r-chain').textContent = stats.bestChain;
    $('r-captured').textContent = stats.captured;
    $('r-streak').textContent = stats.winStreak;
  }, 600);
}

// ===== SHARING =====
function getShareText() {
  const won = stats.winStreak > 0;
  const diff = aiDifficulty === 'hard' ? 'üß† Hard' : 'üå± Easy';
  const lines = [
    won ? `üèÜ I beat the ${diff} AI in Chain Reaction in just ${stats.moves} moves!` : `üíÄ The ${diff} AI crushed me in Chain Reaction after ${stats.moves} moves!`,
    '',
    `üìä My score:`,
    `‚ö° Longest chain: ${stats.bestChain}x`,
    `üí• Orbs captured: ${stats.captured}`,
    stats.winStreak > 1 ? `üî• Win streak: ${stats.winStreak}` : '',
    '',
    won ? `Think you can beat my ${stats.moves}-move win? üëÄ` : `I couldn't beat it ‚Äî can you? ü§î`,
    `Play now and try to beat my score! üëá`,
    `üéÆ ${window.location.href}`
  ];
  return lines.filter(l => l !== undefined && l !== '').join('\n');
}
function getLinkedInText() {
  const won = stats.winStreak > 0;
  const diff = aiDifficulty === 'hard' ? 'üß† Hard' : 'üå± Easy';
  const lines = [
    won ? `üèÜ I just beat the ${diff} AI in Chain Reaction in ${stats.moves} moves!` : `üíÄ The ${diff} AI outsmarted me in Chain Reaction!`,
    '',
    `üìä My score:`,
    `‚ö° Longest chain: ${stats.bestChain}x | üí• Orbs captured: ${stats.captured}`,
    stats.winStreak > 1 ? `üî• Win streak: ${stats.winStreak}` : '',
    '',
    won ? `Think you can beat my ${stats.moves}-move win?` : `I couldn't beat it ‚Äî can you?`,
    ``,
    `Try it yourself üëá`
  ];
  return lines.filter(l => l !== undefined).join('\n');
}
function shareLinkedIn() {
  const url = encodeURIComponent(window.location.href);
  const appUrl = `linkedin://shareArticle?mini=true&url=${url}`;
  const webUrl = `https://www.linkedin.com/sharing/share-offsite/?url=${url}`;
  let appOpened = false;
  const onBlur = () => { appOpened = true; window.removeEventListener('blur', onBlur); };
  window.addEventListener('blur', onBlur);
  window.location.href = appUrl;
  setTimeout(() => {
    window.removeEventListener('blur', onBlur);
    if (!appOpened) window.open(webUrl, '_blank');
  }, 1500);
}
function shareTwitter() {
  window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(getShareText())}`, '_blank');
}
function shareWhatsApp() {
  window.open(`https://wa.me/?text=${encodeURIComponent(getShareText())}`, '_blank');
}
function copyResult() {
  navigator.clipboard.writeText(getShareText()).then(() => {
    const btn = document.querySelector('.copy');
    btn.textContent = '‚úÖ Copied!';
    setTimeout(() => btn.textContent = 'üìã Copy Result', 2000);
  });
}
</script>
<script data-goatcounter="https://frogpond.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
</body>
</html>
