<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Chain Reaction ‚ö°</title>
<meta property="og:title" content="Chain Reaction ‚ö°">
<meta property="og:description" content="Outsmart the AI in this explosive strategy game! Place orbs, trigger chain reactions, dominate the board.">
<style>
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'Inter',sans-serif;background:#0a0a0a;color:#fff;min-height:100vh;display:flex;align-items:center;justify-content:center;overflow:hidden;touch-action:manipulation;-webkit-user-select:none;user-select:none}
.container{width:100%;max-width:420px;padding:1rem;text-align:center}

/* START */
#start-screen{background:#f4f2ee;border-radius:16px;padding:2rem;max-width:400px;width:90%}
#start-screen .logo{font-size:4rem;margin-bottom:0.5rem}
#start-screen h1{font-size:2.4rem;font-weight:900;background:linear-gradient(135deg,#0077B5,#004C75);-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:0.3rem}
#start-screen .sub{color:#666;font-size:0.85rem;margin-bottom:1.5rem;line-height:1.6}
.rules-box{background:#fff;border:1px solid #e0e0e0;border-radius:16px;padding:1.2rem;margin-bottom:1.5rem;text-align:left;font-size:0.8rem;color:#555;line-height:1.7}
.rules-box b{color:#fff}
.btn-play{background:linear-gradient(135deg,#0077B5,#005885);color:#fff;border:none;padding:1rem 3rem;font-size:1.15rem;font-weight:700;border-radius:50px;cursor:pointer;font-family:inherit;transition:transform .2s;box-shadow:0 2px 8px rgba(0,119,181,0.3)}
.btn-play:active{transform:scale(.96)}

/* GAME */
#game-screen{display:none}
.hud{display:flex;justify-content:space-between;align-items:center;margin-bottom:0.8rem;padding:0 0.2rem}
.hud-player{display:flex;align-items:center;gap:0.4rem;font-weight:700;font-size:0.85rem;padding:0.4rem 0.8rem;border-radius:10px;border:2px solid transparent;transition:all .3s}
.hud-player.active{border-color:currentColor}
.hud-player.p1{color:#0077B5}.hud-player.p2{color:#E7A33E}
.hud-center{font-size:0.75rem;color:#555}
.orb-count{font-size:1.1rem}

.grid-wrap{position:relative;margin:0 auto;border-radius:12px;overflow:visible}
.grid{display:grid;gap:3px}
.cell{background:#151515;border-radius:8px;position:relative;cursor:pointer;transition:background .15s,transform .15s;display:flex;align-items:center;justify-content:center;overflow:visible}
.cell:hover{background:#1a1a1a}
.cell.disabled{cursor:default;opacity:0.7}
.cell.flash-p1{background:rgba(0,119,181,0.25)}
.cell.flash-p2{background:rgba(231,163,62,0.25)}
.cell.exploding{transform:scale(1.1);z-index:5}

.orbs{display:flex;flex-wrap:wrap;align-items:center;justify-content:center;gap:2px;position:relative}
.orb{width:12px;height:12px;border-radius:50%;transition:all .2s}
.orb.p1{background:radial-gradient(circle at 35% 35%,#4DA8DA,#0077B5,#004C75);box-shadow:0 0 6px rgba(0,119,181,0.5)}
.orb.p2{background:radial-gradient(circle at 35% 35%,#F5CC84,#E7A33E,#B8781E);box-shadow:0 0 6px rgba(231,163,62,0.5)}

@keyframes wobble{0%,100%{transform:translateY(0)}50%{transform:translateY(-2px)}}
.orb.critical{animation:wobble .4s ease-in-out infinite}

.chain-popup{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:1.5rem;font-weight:900;pointer-events:none;opacity:0;z-index:50;text-shadow:0 2px 8px rgba(0,0,0,0.8)}
@keyframes chainPop{0%{opacity:1;transform:translate(-50%,-50%) scale(0.5)}50%{transform:translate(-50%,-70%) scale(1.2)}100%{opacity:0;transform:translate(-50%,-100%) scale(1)}}
.chain-popup.show{animation:chainPop .8s ease-out forwards}

.flying-orb{position:absolute;width:12px;height:12px;border-radius:50%;z-index:10;pointer-events:none;transition:left .2s ease-out,top .2s ease-out}
.flying-orb.p1{background:radial-gradient(circle at 35% 35%,#4DA8DA,#0077B5);box-shadow:0 0 8px rgba(0,119,181,0.6)}
.flying-orb.p2{background:radial-gradient(circle at 35% 35%,#F5CC84,#E7A33E);box-shadow:0 0 8px rgba(231,163,62,0.6)}

.turn-banner{font-size:0.8rem;color:#555;margin-top:0.8rem;min-height:1.5rem;font-weight:600}
.turn-banner.thinking{color:#E7A33E}

@keyframes shakeGrid{0%,100%{transform:translate(0)}25%{transform:translate(-3px,2px)}50%{transform:translate(2px,-3px)}75%{transform:translate(-2px,1px)}}
.grid-wrap.shake{animation:shakeGrid .25s ease-out}

/* RESULT */
#result-screen{display:none}
.result-emoji{font-size:4rem;margin-bottom:0.5rem}
.result-title{font-size:1.8rem;font-weight:900;margin-bottom:0.2rem}
.result-subtitle{color:#888;font-size:0.9rem;margin-bottom:1.5rem}
.result-stats{display:flex;justify-content:center;gap:1.5rem;margin-bottom:1.5rem}
.stat{text-align:center}
.stat-val{font-size:1.4rem;font-weight:800}
.stat-val.p1{color:#0077B5}.stat-val.p2{color:#E7A33E}
.stat-lbl{font-size:0.65rem;color:#555;text-transform:uppercase;letter-spacing:1px}
.btn-share{width:100%;padding:0.9rem;font-size:0.95rem;font-weight:700;border:none;border-radius:50px;cursor:pointer;font-family:inherit;margin-bottom:0.6rem;color:#fff;transition:transform .2s;display:flex;align-items:center;justify-content:center;gap:0.5rem}
.btn-share:active{transform:scale(.97)}
.btn-share.linkedin{background:#0077b5}
.btn-share.twitter{background:#1da1f2}
.btn-share.whatsapp{background:#25d366}
.btn-share.copy{background:#333}
.btn-replay{background:transparent;color:#888;border:1px solid #333;padding:0.7rem;font-size:0.85rem;font-weight:600;border-radius:50px;cursor:pointer;font-family:inherit;width:100%;margin-top:0.3rem}
.btn-replay:hover{color:#fff;border-color:#555}
</style>
</head>
<body>
<div class="container">

<!-- START SCREEN -->
<div id="start-screen">
  <div class="logo">‚ö°</div>
  <h1>Chain Reaction</h1>
  <p class="sub">Explosive strategy in quick rounds</p>
  <div class="rules-box">
    <b>üîµ You</b> vs <b style="color:#E7A33E">üü° AI</b><br>
    Tap to place orbs in cells.<br>
    When a cell hits <b>critical mass</b>, it explodes into neighbors!<br>
    <b>Corners</b> = 2 ¬∑ <b>Edges</b> = 3 ¬∑ <b>Center</b> = 4<br>
    Explosions <b>capture</b> opponent orbs and can chain!<br>
    <b>Eliminate all opponent orbs to win.</b>
  </div>
  <button class="btn-play" onclick="startGame()">Play ‚ö°</button>
  <p style="margin-top:1.5rem;font-size:0.7rem;color:#999">Created by Dan Shamir & Arlo ü§ñ</p>
</div>

<!-- GAME SCREEN -->
<div id="game-screen">
  <div class="hud">
    <div class="hud-player p1" id="hud-p1">üîµ <span class="orb-count" id="count-p1">0</span></div>
    <div class="hud-center" id="move-count">Move 1</div>
    <div class="hud-player p2" id="hud-p2"><span class="orb-count" id="count-p2">0</span> üü°</div>
  </div>
  <div class="grid-wrap" id="grid-wrap">
    <div class="grid" id="grid"></div>
  </div>
  <div class="turn-banner" id="turn-banner">Your turn ‚Äî tap a cell</div>
</div>

<!-- RESULT SCREEN -->
<div id="result-screen">
  <div class="result-emoji" id="r-emoji"></div>
  <div class="result-title" id="r-title"></div>
  <div class="result-subtitle" id="r-sub"></div>
  <div class="result-stats">
    <div class="stat"><div class="stat-val" id="r-moves">0</div><div class="stat-lbl">Moves</div></div>
    <div class="stat"><div class="stat-val" id="r-chain">0</div><div class="stat-lbl">Best Chain</div></div>
    <div class="stat"><div class="stat-val" id="r-captured">0</div><div class="stat-lbl">Captured</div></div>
    <div class="stat"><div class="stat-val" id="r-streak">0</div><div class="stat-lbl">Win Streak</div></div>
  </div>
  <button class="btn-share linkedin" onclick="shareLinkedIn()">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
    Share on LinkedIn
  </button>
  <button class="btn-share twitter" onclick="shareTwitter()">Share on ùïè</button>
  <button class="btn-share whatsapp" onclick="shareWhatsApp()">Share on WhatsApp</button>
  <button class="btn-share copy" onclick="copyResult()">üìã Copy Result</button>
  <button class="btn-replay" onclick="startGame()">Play Again ‚ö°</button>
  <p style="margin-top:1rem;font-size:0.7rem;color:#444">Created by Dan Shamir & Arlo ü§ñ</p>
</div>

</div>

<script>
// ===== CONSTANTS =====
const ROWS = 9, COLS = 6;
let CELL_SIZE = 50, GAP = 3;
const ANIM_DELAY = 220;

// ===== STATE =====
let board, currentPlayer, totalMoves, animating, gameOver;
let stats = { moves: 0, bestChain: 0, captured: 0, winStreak: 0 };

// ===== AUDIO =====
let audioCtx;
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function playTone(freq, dur, type='sine', vol=0.08) {
  if (!audioCtx) return;
  try {
    const o = audioCtx.createOscillator(), g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol; g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(); o.stop(audioCtx.currentTime + dur);
  } catch(e) {}
}
function sndPlace() { playTone(350, 0.08); }
function sndExplode(n) { playTone(300 + n * 60, 0.12, 'square', 0.06); }
function sndWin() { [523,659,784].forEach((f,i) => setTimeout(() => playTone(f, 0.25), i*100)); }
function sndLose() { [400,350,300].forEach((f,i) => setTimeout(() => playTone(f, 0.25), i*120)); }

// ===== BOARD LOGIC =====
function critMass(r, c) {
  let n = 4;
  if (r === 0 || r === ROWS-1) n--;
  if (c === 0 || c === COLS-1) n--;
  return n;
}
function neighbors(r, c) {
  const ns = [];
  if (r > 0) ns.push([r-1,c]);
  if (r < ROWS-1) ns.push([r+1,c]);
  if (c > 0) ns.push([r,c-1]);
  if (c < COLS-1) ns.push([r,c+1]);
  return ns;
}
function countOrbs(b, player) {
  let n = 0;
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (b[r][c].owner === player) n += b[r][c].count;
  return n;
}
function deepCopy(b) {
  return b.map(row => row.map(cell => ({...cell})));
}
function isGameOver(b) {
  if (totalMoves < 2) return 0;
  const p1 = countOrbs(b, 1), p2 = countOrbs(b, 2);
  if (p1 === 0) return 2;
  if (p2 === 0) return 1;
  return 0;
}

// Pure simulation (no animation)
function simulate(b, r, c, player) {
  b[r][c].count++;
  b[r][c].owner = player;
  let chainLen = 0, captured = 0, iters = 0;
  while (iters++ < 200) {
    const toExplode = [];
    for (let rr = 0; rr < ROWS; rr++)
      for (let cc = 0; cc < COLS; cc++)
        if (b[rr][cc].count >= critMass(rr, cc)) toExplode.push([rr,cc]);
    if (!toExplode.length) break;
    chainLen++;
    for (const [er, ec] of toExplode) {
      b[er][ec].count -= critMass(er, ec);
      if (b[er][ec].count <= 0) { b[er][ec].count = 0; b[er][ec].owner = 0; }
      for (const [nr, nc] of neighbors(er, ec)) {
        if (b[nr][nc].owner !== 0 && b[nr][nc].owner !== player) captured++;
        b[nr][nc].count++;
        b[nr][nc].owner = player;
      }
    }
    // Check early termination
    let p1 = false, p2 = false;
    for (let rr = 0; rr < ROWS; rr++)
      for (let cc = 0; cc < COLS; cc++) {
        if (b[rr][cc].owner === 1) p1 = true;
        if (b[rr][cc].owner === 2) p2 = true;
      }
    if (totalMoves >= 1 && (!p1 || !p2)) break;
  }
  return { board: b, chainLen, captured };
}

// ===== AI =====
function aiMove() {
  const valid = [];
  for (let r = 0; r < ROWS; r++)
    for (let c = 0; c < COLS; c++)
      if (board[r][c].owner === 0 || board[r][c].owner === 2)
        valid.push([r, c]);

  let bestScore = -Infinity, bestMoves = [];
  for (const [r, c] of valid) {
    const sim = deepCopy(board);
    const result = simulate(sim, r, c, 2);

    let score = 0;
    const myOrbs = countOrbs(result.board, 2);
    const theirOrbs = countOrbs(result.board, 1);

    // Win = instant pick
    if (totalMoves >= 1 && theirOrbs === 0) return [r, c];

    score += myOrbs * 2 - theirOrbs * 2;

    // Count cells
    let myCells = 0, theirCells = 0;
    for (let rr = 0; rr < ROWS; rr++)
      for (let cc = 0; cc < COLS; cc++) {
        if (result.board[rr][cc].owner === 2) myCells++;
        if (result.board[rr][cc].owner === 1) theirCells++;
      }
    score += (myCells - theirCells) * 3;

    // Captures are great
    score += result.captured * 5;

    // Prefer corners and edges (safer positions)
    const cm = critMass(r, c);
    if (cm === 2) score += 4;
    else if (cm === 3) score += 1;

    // Avoid placing next to opponent's near-critical cells (if no explosion)
    if (result.chainLen === 0) {
      for (const [nr, nc] of neighbors(r, c)) {
        if (board[nr][nc].owner === 1 && board[nr][nc].count === critMass(nr, nc) - 1) {
          score -= 12;
        }
      }
    }

    // Prefer building up cells that are close to critical (pressure)
    if (board[r][c].owner === 2 && board[r][c].count === critMass(r, c) - 1) {
      // This would explode ‚Äî check if it captures
      score += result.captured > 0 ? 10 : -3;
    }

    if (score > bestScore) { bestScore = score; bestMoves = [[r, c]]; }
    else if (score === bestScore) bestMoves.push([r, c]);
  }
  // Pick randomly among best moves
  return bestMoves[Math.floor(Math.random() * bestMoves.length)];
}

// ===== RENDERING =====
const $ = id => document.getElementById(id);
const gridEl = $('grid');
const gridWrap = $('grid-wrap');

function initGrid() {
  // Calculate cell size based on screen
  const maxW = Math.min(420, window.innerWidth - 32);
  CELL_SIZE = Math.floor((maxW - GAP * (COLS - 1)) / COLS);
  const gridW = CELL_SIZE * COLS + GAP * (COLS - 1);
  const gridH = CELL_SIZE * ROWS + GAP * (ROWS - 1);

  gridEl.style.gridTemplateColumns = `repeat(${COLS}, ${CELL_SIZE}px)`;
  gridEl.style.gridTemplateRows = `repeat(${ROWS}, ${CELL_SIZE}px)`;
  gridEl.style.gap = GAP + 'px';
  gridWrap.style.width = gridW + 'px';
  gridWrap.style.height = gridH + 'px';

  gridEl.innerHTML = '';
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.addEventListener('click', () => onCellClick(r, c));
      const orbsDiv = document.createElement('div');
      orbsDiv.className = 'orbs';
      cell.appendChild(orbsDiv);
      gridEl.appendChild(cell);
    }
  }
}

function cellEl(r, c) { return gridEl.children[r * COLS + c]; }

function cellCenter(r, c) {
  return {
    x: c * (CELL_SIZE + GAP) + CELL_SIZE / 2,
    y: r * (CELL_SIZE + GAP) + CELL_SIZE / 2
  };
}

function renderBoard() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = cellEl(r, c);
      const orbsDiv = cell.querySelector('.orbs');
      const { count, owner } = board[r][c];
      const isCrit = count === critMass(r, c) - 1 && owner !== 0;

      orbsDiv.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const orb = document.createElement('div');
        orb.className = `orb p${owner}${isCrit ? ' critical' : ''}`;
        orbsDiv.appendChild(orb);
      }
    }
  }
  // Update HUD
  $('count-p1').textContent = countOrbs(board, 1);
  $('count-p2').textContent = countOrbs(board, 2);
  $('hud-p1').classList.toggle('active', currentPlayer === 1 && !gameOver);
  $('hud-p2').classList.toggle('active', currentPlayer === 2 && !gameOver);
}

// ===== ANIMATED EXPLOSIONS =====
function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

async function animatedPlace(r, c, player) {
  board[r][c].count++;
  board[r][c].owner = player;
  renderBoard();
  sndPlace();

  let chainLen = 0, totalCaptured = 0, iters = 0;

  while (iters++ < 200) {
    const toExplode = [];
    for (let rr = 0; rr < ROWS; rr++)
      for (let cc = 0; cc < COLS; cc++)
        if (board[rr][cc].count >= critMass(rr, cc)) toExplode.push([rr, cc]);
    if (!toExplode.length) break;
    chainLen++;
    sndExplode(chainLen);

    // Create flying orbs
    const flyingOrbs = [];
    for (const [er, ec] of toExplode) {
      const from = cellCenter(er, ec);
      cellEl(er, ec).classList.add('exploding');

      board[er][ec].count -= critMass(er, ec);
      if (board[er][ec].count <= 0) { board[er][ec].count = 0; board[er][ec].owner = 0; }

      for (const [nr, nc] of neighbors(er, ec)) {
        if (board[nr][nc].owner !== 0 && board[nr][nc].owner !== player) totalCaptured++;
        const to = cellCenter(nr, nc);
        const orb = document.createElement('div');
        orb.className = `flying-orb p${player}`;
        orb.style.left = (from.x - 6) + 'px';
        orb.style.top = (from.y - 6) + 'px';
        gridWrap.appendChild(orb);
        flyingOrbs.push(orb);
        // Trigger transition
        requestAnimationFrame(() => requestAnimationFrame(() => {
          orb.style.left = (to.x - 6) + 'px';
          orb.style.top = (to.y - 6) + 'px';
        }));
      }
    }

    renderBoard();
    await delay(ANIM_DELAY);

    // Apply to neighbors
    for (const [er, ec] of toExplode) {
      cellEl(er, ec).classList.remove('exploding');
      for (const [nr, nc] of neighbors(er, ec)) {
        board[nr][nc].count++;
        board[nr][nc].owner = player;
        cellEl(nr, nc).classList.add(`flash-p${player}`);
      }
    }
    renderBoard();
    flyingOrbs.forEach(o => o.remove());

    // Chain popup
    if (chainLen >= 2) showChainPopup(chainLen, toExplode[0]);
    if (chainLen >= 4) gridWrap.classList.add('shake');

    await delay(80);
    // Clear flash
    for (const [er, ec] of toExplode)
      for (const [nr, nc] of neighbors(er, ec))
        cellEl(nr, nc).classList.remove(`flash-p1`, `flash-p2`);
    gridWrap.classList.remove('shake');

    // Check game over mid-chain
    const winner = isGameOver(board);
    if (winner) { endGame(winner); return { chainLen, captured: totalCaptured }; }
  }

  if (chainLen > stats.bestChain) stats.bestChain = chainLen;
  stats.captured += totalCaptured;
  return { chainLen, captured: totalCaptured };
}

function showChainPopup(n, srcCell) {
  const popup = document.createElement('div');
  popup.className = 'chain-popup';
  const colors = ['', '#0077B5', '#E7A33E'];
  popup.style.color = n >= 5 ? '#fbbf24' : colors[currentPlayer] || '#fff';
  popup.textContent = n >= 5 ? `üí• ${n}x CHAIN!` : `‚ö° ${n}x`;
  popup.style.left = '50%'; popup.style.top = '50%';
  gridWrap.appendChild(popup);
  requestAnimationFrame(() => popup.classList.add('show'));
  setTimeout(() => popup.remove(), 900);
}

// ===== GAME FLOW =====
function startGame() {
  initAudio();
  board = [];
  for (let r = 0; r < ROWS; r++) {
    board[r] = [];
    for (let c = 0; c < COLS; c++) board[r][c] = { count: 0, owner: 0 };
  }
  currentPlayer = 1;
  totalMoves = 0;
  animating = false;
  gameOver = false;
  stats.moves = 0;
  stats.bestChain = 0;
  stats.captured = 0;

  $('start-screen').style.display = 'none';
  $('result-screen').style.display = 'none';
  $('game-screen').style.display = 'block';

  initGrid();
  renderBoard();
  updateTurnBanner();
}

function updateTurnBanner() {
  const banner = $('turn-banner');
  if (currentPlayer === 1) {
    banner.textContent = 'Your turn ‚Äî tap a cell';
    banner.className = 'turn-banner';
  } else {
    banner.textContent = 'AI is thinking...';
    banner.className = 'turn-banner thinking';
  }
}

async function onCellClick(r, c) {
  if (animating || gameOver || currentPlayer !== 1) return;
  if (board[r][c].owner !== 0 && board[r][c].owner !== 1) return;

  animating = true;
  totalMoves++;
  stats.moves++;
  $('move-count').textContent = `Move ${stats.moves}`;

  await animatedPlace(r, c, 1);

  if (gameOver) return;

  // AI turn
  currentPlayer = 2;
  updateTurnBanner();
  await delay(400 + Math.random() * 300);

  if (gameOver) return;

  const [ar, ac] = aiMove();
  totalMoves++;
  await animatedPlace(ar, ac, 2);

  if (gameOver) return;

  currentPlayer = 1;
  animating = false;
  updateTurnBanner();
}

function endGame(winner) {
  gameOver = true;
  animating = false;

  if (winner === 1) {
    stats.winStreak++;
    sndWin();
  } else {
    stats.winStreak = 0;
    sndLose();
  }

  setTimeout(() => {
    $('game-screen').style.display = 'none';
    $('result-screen').style.display = 'block';

    if (winner === 1) {
      $('r-emoji').textContent = 'üèÜ';
      $('r-title').textContent = 'You Won!';
      $('r-sub').textContent = 'The AI has been eliminated.';
    } else {
      $('r-emoji').textContent = 'üíÄ';
      $('r-title').textContent = 'AI Wins';
      $('r-sub').textContent = 'The machine outsmarted you this time.';
    }

    $('r-moves').textContent = stats.moves;
    $('r-moves').className = `stat-val p${winner}`;
    $('r-chain').textContent = stats.bestChain;
    $('r-captured').textContent = stats.captured;
    $('r-streak').textContent = stats.winStreak;
  }, 600);
}

// ===== SHARING =====
function getShareText() {
  const won = stats.winStreak > 0;
  const lines = [
    won ? `üèÜ I beat the AI in Chain Reaction in ${stats.moves} moves!` : `üíÄ The AI got me in Chain Reaction after ${stats.moves} moves!`,
    '',
    `‚ö° Longest chain: ${stats.bestChain}x`,
    `üí• Orbs captured: ${stats.captured}`,
    stats.winStreak > 1 ? `üî• Win streak: ${stats.winStreak}` : '',
    '',
    `Can you outsmart the AI?`,
    `üéÆ ${window.location.href}`
  ];
  return lines.filter(l => l !== undefined).join('\n');
}
function shareLinkedIn() {
  window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(window.location.href)}`, '_blank');
}
function shareTwitter() {
  window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(getShareText())}`, '_blank');
}
function shareWhatsApp() {
  window.open(`https://wa.me/?text=${encodeURIComponent(getShareText())}`, '_blank');
}
function copyResult() {
  navigator.clipboard.writeText(getShareText()).then(() => {
    const btn = document.querySelector('.copy');
    btn.textContent = '‚úÖ Copied!';
    setTimeout(() => btn.textContent = 'üìã Copy Result', 2000);
  });
}
</script>
</body>
</html>
